import{_ as t,c as a,o,ag as i}from"./chunks/framework.BgId8OS5.js";const n="/assets/OAuth.YieJai55.png",r="/assets/session-authentication.CDD4MZN7.png",s="/assets/jwt-authentication.4t34tHtd.png",h="/assets/sso.BFFWOyJt.png",c="/assets/auth1.DvgVga3G.png",p="/assets/auth2.BoHOhchC.png",g=JSON.parse('{"title":"Auth","description":"","frontmatter":{},"headers":[],"relativePath":"backEnd/base/auth.md","filePath":"backEnd/base/auth.md","lastUpdated":1733410081000}'),u={name:"backEnd/base/auth.md"};function d(l,e,m,f,k,A){return o(),a("div",null,e[0]||(e[0]=[i('<h1 id="auth" tabindex="-1">Auth <a class="header-anchor" href="#auth" aria-label="Permalink to &quot;Auth&quot;">​</a></h1><h2 id="authentication-authorization" tabindex="-1">Authentication &amp; Authorization <a class="header-anchor" href="#authentication-authorization" aria-label="Permalink to &quot;Authentication &amp; Authorization&quot;">​</a></h2><ul><li>Authentication: Verifies if the user is who they say they are. It requires the user to prove their identity with something they have, such as a username and password. 用户认证：验证用户的身份，确认用户是谁。一般使用账号密码实现。</li><li>Authorization: Decides what routes and data the user can access. 用户授权：确定用户是否有权限执行某个操作，确定用户可以做什么。</li></ul><p>Below are found in the <a href="https://roadmap.sh/backend" target="_blank" rel="noreferrer">backend roadmap</a> Authentication items.</p><h2 id="basic-authentication" tabindex="-1">Basic Authentication <a class="header-anchor" href="#basic-authentication" aria-label="Permalink to &quot;Basic Authentication&quot;">​</a></h2><p><img src="https://roadmap.sh/guides/basic-authentication.png" alt=""></p><h2 id="oauth-—-open-authorization" tabindex="-1">OAuth — Open Authorization <a class="header-anchor" href="#oauth-—-open-authorization" aria-label="Permalink to &quot;OAuth — Open Authorization&quot;">​</a></h2><p>From: <a href="https://roadmap.sh/guides/oauth" target="_blank" rel="noreferrer">https://roadmap.sh/guides/oauth</a><img src="'+n+'" alt=""></p><h2 id="token-based-authentication" tabindex="-1">Token Based Authentication <a class="header-anchor" href="#token-based-authentication" aria-label="Permalink to &quot;Token Based Authentication&quot;">​</a></h2><p><img src="https://roadmap.sh/guides/token-authentication.png" alt=""></p><h2 id="session-based-authentication" tabindex="-1">Session Based Authentication <a class="header-anchor" href="#session-based-authentication" aria-label="Permalink to &quot;Session Based Authentication&quot;">​</a></h2><p>From: <a href="https://roadmap.sh/guides/session-authentication" target="_blank" rel="noreferrer">https://roadmap.sh/guides/session-authentication</a></p><p><img src="'+r+'" alt=""></p><h2 id="jwt-authentication" tabindex="-1">JWT Authentication <a class="header-anchor" href="#jwt-authentication" aria-label="Permalink to &quot;JWT Authentication&quot;">​</a></h2><p>From: <a href="https://roadmap.sh/guides/jwt-authentication" target="_blank" rel="noreferrer">https://roadmap.sh/guides/jwt-authentication</a></p><p><img src="'+s+'" alt=""></p><h3 id="sso" tabindex="-1">SSO <a class="header-anchor" href="#sso" aria-label="Permalink to &quot;SSO&quot;">​</a></h3><p>From: <a href="https://roadmap.sh/guides/sso.png" target="_blank" rel="noreferrer">https://roadmap.sh/guides/sso.png</a></p><p><img src="'+h+'" alt=""></p><h2 id="oauth-2-0-协议及相关概念" tabindex="-1">OAuth 2.0 协议及相关概念 <a class="header-anchor" href="#oauth-2-0-协议及相关概念" aria-label="Permalink to &quot;OAuth 2.0 协议及相关概念&quot;">​</a></h2><p>在认证与授权方面，经常会提及的两个协议：OAuth 2.0 协议和OpenID connect 协议，其中OAuth 2.0定义了授权相关概念，OpenID connect 定义了认证相关概念。</p><h3 id="oauth-2-0-协议和openid-connect-协议" tabindex="-1">OAuth 2.0 协议和OpenID connect 协议 <a class="header-anchor" href="#oauth-2-0-协议和openid-connect-协议" aria-label="Permalink to &quot;OAuth 2.0 协议和OpenID connect 协议&quot;">​</a></h3><p>OAuth 2.0 在RFC6749的定义是：</p><blockquote><p>OAuth 2.0 框架能让第三方应用以有限的权限访问 HTTP 服务，可以通过构建资源 拥有者与 HTTP 服务间的许可交互机制，让第三方应用代表资源拥有者访问服务，或者 通过授予权限给第三方应用，让其代表自己访问服务。</p></blockquote><p>OAuth 2.0 是一个授权协议，它允许软件代表资源拥有者去访问资源拥有者的资源。应用向资源拥有者请求授权，然后取得令牌(token)，并用它来访问资源。</p><p><img src="'+c+'" alt=""></p><p>OpenID Connect是一个位于OAuth 2.0框架之上的协议。它定义了一种使用 OAuth 2.0 执行用户身份认证的互通方式。</p><p>OAuth 2.0 协议通过<code>access token</code>提供授权，OpenID connect 协议引入了<code>id token</code>的概念，用作认证。</p><h2 id="authorization-code-flow" tabindex="-1">Authorization Code Flow <a class="header-anchor" href="#authorization-code-flow" aria-label="Permalink to &quot;Authorization Code Flow&quot;">​</a></h2><p>OAuth 2.0 协议定义了多种授权方式，在这里主要说明的是Authorization Code这种方式。在详细描述授权方式之前，由几个基本概念需要了解。</p><ul><li><p>资源所有者（resource owner）：资源所有者是能够授予对受保护资源的访问权限的实体。当资源所有者是一个人时，它被称为终端用户。</p></li><li><p>资源服务器（resource server）：托管受保护资源的服务器，能够接受和响应使用访问令牌（access token）对受保护资源的请求。</p></li><li><p>客户端（client）：是代表资源所有者访问受保护资源的软件。</p></li><li><p>授权服务器（authorization server）：服务器在成功认证资源所有者并获得授权后向客户端颁发访问令牌（access token）。</p></li><li><p>Authorization Code授权方式分为两步，第一步客户端引导用户完成在授权服务器上的认证，获取到code，第二步客户端使用code在授权服务器获取到token。</p></li></ul><p><img src="'+p+'" alt=""></p><ul><li><p>客户端是需要在授权服务器预先注册的，注册成功之后客户端会得到授权服务器颁发的client id 和 client secret（要找个第三方当可靠的中间人，大家总要彼此认识认识吧）。</p></li><li><p>❶ 中发出的请求会携带参数client id和state，其中state是由客户端生成的随机字符串，会在❹中返回。客户端在发送❺的请求之前会校验state，这么做的原因是为了防止跨站攻击。</p></li><li><p>❷❸ 是资源所有者，一般是用户对来自授权服务器的请求进行授权。</p></li><li><p>❹ 客户端得到授权服务器返回的code和state。</p></li><li><p>❺ 客户端携带client id，client secret，code， response type，scope等参数向授权服务器发起请求。</p></li><li><p>❻ 授权服务器返回access token给客户端。</p></li><li><p>❼❽客户端携带access token向资源服务器发起对受保护资源的请求并得到响应。</p></li></ul><h3 id="pkce-proof-key-for-code-exchange-flow" tabindex="-1">PKCE （Proof Key for Code Exchange）Flow <a class="header-anchor" href="#pkce-proof-key-for-code-exchange-flow" aria-label="Permalink to &quot;PKCE （Proof Key for Code Exchange）Flow&quot;">​</a></h3><p>PKCE（Proof Key for Code Exchange）是增强版的Authorization Code授权方式，为了防止CSRF和授权码注入攻击。什么是授权码注入攻击？</p><p>假设在上图中❹返回的code被劫持，那么攻击方在预先获取客户端的client id 的情况下，可以模拟请求方发送请求给授权服务器获得token。</p><p>PKCE的引入就是为了防范这种攻击的。具体就是在上图中❶中引入额外的参数code verifier 和code challenge。code verifier 是客户端随机生成的字符串，在43-128位之间，由<code>[A-Z]</code> / <code>[a-z]</code> / <code>[0-9]</code> / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot;组成。code challenge的计算公式是BASE64URL-ENCODE(SHA256(ASCII(code verifier)))，如果客户端不支持SHA256编码，那么code challenge的值就是code verifier。code challenge会被存储在授权服务器端，在❺中客户端会带上code verifier参数，授权服务器会把code verifier和存储的code challenge 在处理之后作比对，防止授权码的注入攻击。</p><h3 id="集成openid-connect做认证" tabindex="-1">集成OpenID connect做认证 <a class="header-anchor" href="#集成openid-connect做认证" aria-label="Permalink to &quot;集成OpenID connect做认证&quot;">​</a></h3><p>如何集成OpenID connect到上述流程中做认证？</p><p>在上述的流程中，❺ 中请求的参数scope可以设置为openid,标识该请求希望获取授权服务器上的用户信息，那么在❻中返回的token集合除了包含access token， refresh token，还会包含id token。id token是OpenID connect 协议引入的，id token中包含了用户的信息。</p>',40)]))}const _=t(u,[["render",d]]);export{g as __pageData,_ as default};
