import{_ as a,c as n,o as s,ag as t}from"./chunks/framework.BgId8OS5.js";const u=JSON.parse('{"title":"Prompt","description":"","frontmatter":{},"headers":[],"relativePath":"backEnd/ai/prompt.md","filePath":"backEnd/ai/prompt.md","lastUpdated":1749566229000}'),i={name:"backEnd/ai/prompt.md"};function p(l,e,o,r,c,d){return s(),n("div",null,e[0]||(e[0]=[t(`<h1 id="prompt" tabindex="-1">Prompt <a class="header-anchor" href="#prompt" aria-label="Permalink to &quot;Prompt&quot;">​</a></h1><h2 id="react" tabindex="-1">React <a class="header-anchor" href="#react" aria-label="Permalink to &quot;React&quot;">​</a></h2><h4 id="single-responsibility-principle-in-react" tabindex="-1"><a href="https://cekrem.github.io/posts/single-responsibility-principle-in-react/" target="_blank" rel="noreferrer">Single Responsibility Principle in React</a> <a class="header-anchor" href="#single-responsibility-principle-in-react" aria-label="Permalink to &quot;[Single Responsibility Principle in React](https://cekrem.github.io/posts/single-responsibility-principle-in-react/)&quot;">​</a></h4><p>Key Takeaways</p><ol><li>Separate data and presentation - use hooks for data, components for UI</li><li>Create focused components - each component should do one thing well</li><li>Use composition to build complex features from simple parts</li><li>Extract reusable logic into custom hooks</li><li>Think in layers - data, business logic, presentation</li></ol><h2 id="v0" tabindex="-1">v0 <a class="header-anchor" href="#v0" aria-label="Permalink to &quot;v0&quot;">​</a></h2><p>When generating React component:</p><ul><li>Always use TypeScript.</li><li>Avoid using any type.</li><li>Always use Shadcn and Tailwind.</li><li>Don&#39;t type React.FC on the component.</li><li>use const instead of function for the component.</li><li>The component must adhere to composable pattern of React.</li><li>Don&#39;t overuse useState and useEffect hooks. Use computed state if possible.</li><li>Use useMemo and useCallback when necessary to prevent unnecessary rendering.</li><li>Use server action and useActionState if possible. Otherwise, use fetch and API route handler. When the component needs to do data mutation, make it so that it accepts server action as props.</li><li>Create server component if possible. Otherwise, create client component.</li><li>Use Suspense and streaming when possible.</li><li>Always validate inputs using zod in the server action and API end point.</li><li>When possible create a custom hook to group useState and useEffect that encapsulates certain logic.</li><li>Create a higher order component when needed to add certain functionalities that are not completely coupled to the component.</li><li>When makes sense, combine related components, hooks, functions in the same file so that it&#39;s easy to distribute and use.</li><li>Text content must be HTML-escaped.</li></ul><h3 id="代码坏味道重构ai提示" tabindex="-1"><a href="https://aigo.netlify.app/docs/codesemell/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93/#%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E9%87%8D%E6%9E%84ai%E6%8F%90%E7%A4%BA" target="_blank" rel="noreferrer">代码坏味道重构AI提示</a> <a class="header-anchor" href="#代码坏味道重构ai提示" aria-label="Permalink to &quot;[代码坏味道重构AI提示](https://aigo.netlify.app/docs/codesemell/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93/#%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E9%87%8D%E6%9E%84ai%E6%8F%90%E7%A4%BA)&quot;">​</a></h3><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Context:</span></span>
<span class="line"><span>You are working on a codebase that has been growing over time. During a recent review, you identified several common code smells, including:</span></span>
<span class="line"><span>	- Long Methods</span></span>
<span class="line"><span>	- Long Parameter List</span></span>
<span class="line"><span>	- Duplicated Code</span></span>
<span class="line"><span>	- Dead Code</span></span>
<span class="line"><span>Your goal is to refactor the code to improve readability, maintainability, and overall quality.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Constraint:</span></span>
<span class="line"><span>    - Create a new file whenever a new class needs to be created</span></span>
<span class="line"><span>    - Fix text should not change the case and implementation code</span></span>
<span class="line"><span>    - When writing tests, duplicate code can be allowed</span></span>
<span class="line"><span>    - Avoid using duplicate names when naming</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Based on the above contexts. You will use the ReAct framework to guide this process to analyze, observe, execute, and finally complete the code refactoring.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Thought-1:</span></span>
<span class="line"><span>I need to identify specific code smells in the current implementation to determine what refactoring techniques to apply.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Observation-1:</span></span>
<span class="line"><span>I’ve found a Long Method that spans over n lines and performs multiple tasks. Additionally, there are instances of Duplicated Code where similar logic appears in three different places. Lastly, there are some Long Parameter List exists.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Action-1:</span></span>
<span class="line"><span>1. For the Long Method:</span></span>
<span class="line"><span>   I will apply the *Extract Method* technique to break this method into smaller, more focused methods.</span></span>
<span class="line"><span>2. For the Duplicated Code:</span></span>
<span class="line"><span>   I will use the *Extract Method* technique to consolidate the duplicated logic into a single reusable method.</span></span>
<span class="line"><span>3. For the Long Parameter:</span></span>
<span class="line"><span>   I will Introduce Parameter Object to simplify parameter passing.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Thought-2:</span></span>
<span class="line"><span>Now that I’ve addressed the Long Method, Duplicated Code, I should check for any remaining code smells like Dead Code</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Observation-2:</span></span>
<span class="line"><span>I discovered several methods that are no longer called anywhere in the code (Dead Code).</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Action-2:</span></span>
<span class="line"><span>For the Dead Code:</span></span>
<span class="line"><span>I will safely remove these unused methods after confirming they are not referenced anywhere else in the codebase.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Thought-3:</span></span>
<span class="line"><span>Now that I’ve addressed Duplicated Code, I should check if the related tests are broken</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Observation-3:</span></span>
<span class="line"><span>I discovered several tests that are broken</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Action-3:</span></span>
<span class="line"><span>I&#39;ll fix these tests without changing the scene</span></span></code></pre></div><h2 id="cursor" tabindex="-1">Cursor <a class="header-anchor" href="#cursor" aria-label="Permalink to &quot;Cursor&quot;">​</a></h2><p><a href="https://cursor.directory/" target="_blank" rel="noreferrer">cursor</a></p>`,12)]))}const m=a(i,[["render",p]]);export{u as __pageData,m as default};
