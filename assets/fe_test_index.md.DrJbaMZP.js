import{_ as t,c as a,o as r,ag as i}from"./chunks/framework.BgId8OS5.js";const p=JSON.parse('{"title":"杂项","description":"","frontmatter":{},"headers":[],"relativePath":"fe/test/index.md","filePath":"fe/test/index.md","lastUpdated":1711981558000}'),l={name:"fe/test/index.md"};function o(n,e,s,d,h,c){return r(),a("div",null,e[0]||(e[0]=[i('<h1 id="杂项" tabindex="-1">杂项 <a class="header-anchor" href="#杂项" aria-label="Permalink to &quot;杂项&quot;">​</a></h1><h2 id="测试替身" tabindex="-1"><a href="https://martinfowler.com/bliki/TestDouble.html" target="_blank" rel="noreferrer">测试替身</a> <a class="header-anchor" href="#测试替身" aria-label="Permalink to &quot;[测试替身](https://martinfowler.com/bliki/TestDouble.html)&quot;">​</a></h2><p>SUT（System Under Test）为被测对象，DOC（Depended On Component）为被测对象所依赖的组件。引入测试替身（Test Double）替换掉 DOC，这样就可以有效地控制 SUT 的依赖，降低 DOC 自身的复杂性对 SUT 的影响。</p><ul><li>Test Stub，控制 DOC 对 SUT 的间接输入，提供现成的返回结果给测试期间发生的函数调用。通常，除了测试中用到的case外，什么也不会返回。</li><li>Test Spy，在 Test Stub 的基础上记录和验证 SUT 对 DOC 的间接输出</li><li>Mock Object，验证 SUT 和 DOC 的交互是否正确，一种的特殊的Stub，记录了替身是如何被调用。</li><li>Fake Object，提供与真实 DOC 相同或有缩减的功能</li><li>Dummy Object，占位符，测试中不会实际使用它，通常被用来填充参数列表。</li></ul><h2 id="黑盒测试和白盒测试" tabindex="-1">黑盒测试和白盒测试 <a class="header-anchor" href="#黑盒测试和白盒测试" aria-label="Permalink to &quot;黑盒测试和白盒测试&quot;">​</a></h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95" target="_blank" rel="noreferrer">黑盒测试</a> 也可以称为功能测试、数据驱动测试或基于规格说明的测试。测试者<strong>不了解程序的内部情况</strong>，不需具备应用程序的代码、内部结构和编程语言的专门知识。只知道程序的输入、输出和系统的功能，这是从用户的角度针对软件界面、功能及外部结构进行测试，而不考虑程序内部逻辑结构。</li><li><a href="https://zh.wikipedia.org/wiki/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95" target="_blank" rel="noreferrer">白盒测试</a> 测试应用程序的内部结构或运作，而不是测试应用程序的功能（即黑盒测试）。在白盒测试时，以编程语言的角度来设计测试案例。测试者输入资料验证资料流在程序中的流动路径，并确定适当的输出，类似测试电路中的节点。测试者了解待测试程序的内部结构、算法等信息，这是从程序设计者的角度对程序进行的测试。</li></ul>',6)]))}const f=t(l,[["render",o]]);export{p as __pageData,f as default};
