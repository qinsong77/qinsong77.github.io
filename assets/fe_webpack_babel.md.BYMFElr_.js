import{_ as a,c as i,o as n,ag as e}from"./chunks/framework.BgId8OS5.js";const l="/assets/babel.C7BjXBNB.png",t="/assets/babel_Architecture.BP174a-E.png",p="/assets/babel_process.D7bDG82z.png",o="/assets/babe_tool_package.CQ8_YK1w.png",r="/assets/polyfill_1.B1SG5HZ0.png",h="/assets/core_js.g6TpZfRW.png",k="/assets/babel_polyfill_process.BbMCe2L4.png",m=JSON.parse('{"title":"Babel","description":"","frontmatter":{"title":"Babel"},"headers":[],"relativePath":"fe/webpack/babel.md","filePath":"fe/webpack/babel.md","lastUpdated":1724397889000}'),c={name:"fe/webpack/babel.md"};function d(E,s,u,g,b,y){return n(),i("div",null,s[0]||(s[0]=[e('<h1 id="babel" tabindex="-1">Babel <a class="header-anchor" href="#babel" aria-label="Permalink to &quot;Babel&quot;">​</a></h1><p><strong>Babel is a JavaScript compiler.</strong></p><p>Babel就是一个JavaScript编译器，babel编译分为三个阶段，<strong>解析（parse），转换（transform），生成（generate）</strong>。解析过程又可分为<strong>词法解析</strong>和<strong>语法解析</strong>两个过程。 Babel本身不支持转换，转换是通过一个个 plugin实现。</p><p><img src="'+l+'" alt=""></p><h2 id="babel的架构" tabindex="-1">Babel的架构 <a class="header-anchor" href="#babel的架构" aria-label="Permalink to &quot;Babel的架构&quot;">​</a></h2><p><img src="'+t+'" alt=""></p><hr><p><img src="'+p+'" alt=""></p><h4 id="相关文章" tabindex="-1">相关文章 <a class="header-anchor" href="#相关文章" aria-label="Permalink to &quot;相关文章&quot;">​</a></h4><ul><li><a href="https://juejin.cn/post/7151653067593613320" target="_blank" rel="noreferrer">一文聊完前端项目中的Babel配置</a></li><li><a href="https://mp.weixin.qq.com/s/Ngehh9RoG6lrQATxddn-iQ" target="_blank" rel="noreferrer">Babel 可以这样学！</a></li><li><a href="https://mp.weixin.qq.com/s/1OyBkl5NnFO1q86L7GjQwg" target="_blank" rel="noreferrer">Babel介绍</a></li><li><a href="https://juejin.cn/post/6844904008679686152" target="_blank" rel="noreferrer">Babel7</a></li><li><a href="https://juejin.cn/post/6844903956905197576" target="_blank" rel="noreferrer">深入浅出 Babel</a></li></ul><h4 id="parse" tabindex="-1">parse <a class="header-anchor" href="#parse" aria-label="Permalink to &quot;parse&quot;">​</a></h4><p>分为<strong>词法解析</strong>(Lexical Analysis)和<strong>语法解析</strong>(Syntactic Analysis)</p><p>词法解析器(Tokenizer)在这个阶段将字符串形式的代码转换为Tokens(令牌). Tokens 可以视作是一些语法片段组成的数组， 每个 Token 中包含了语法片段、位置信息、以及一些类型信息. 这些信息有助于后续的语法分析。词法分析可以简单的理解为分词，利用存在的编程规则，进行匹配转换成token。</p><p>词法分析被抽象为了一个“有限状态自动机”，在某个状态下，满足一些条件后，会进行状态转移，转移到新的状态，从代码层面看，是一系列的 switch case 语句。经过词法分析后，代码被准确的切割，每个被切分的词叫做 <code>token</code>。</p><p>语法解析： 语法解析器(Parser)会把Tokens转换为抽象语法树(Abstract Syntax Tree，AST)，要做到语法分析，其实要做的就是对于语言要进行建模与抽象，就是一系列的规则的匹配与嵌套，优先级低的规则嵌套优先级高的规则（这样才能保证优先级高的先执行）</p><h4 id="transform" tabindex="-1">transform <a class="header-anchor" href="#transform" aria-label="Permalink to &quot;transform&quot;">​</a></h4><p>AST 遍历和转换会使用<strong>访问者模式</strong>。访问者会以<code>深度优先</code>的顺序, 或者说<code>递归</code>地对 AST 进行遍历, <code>@babel/traverse</code>，实现了访问者模式，对 AST 进行遍历，<strong>转换插件</strong>会通过它获取感兴趣的AST节点，对节点继续操作</p><p><img src="'+o+`" alt=""></p><h4 id="插件集-preset-env" tabindex="-1">插件集 preset-env <a class="header-anchor" href="#插件集-preset-env" aria-label="Permalink to &quot;插件集 preset-env&quot;">​</a></h4><p><code>preset-env</code> 也是 Babel 提供的预设插件集之一，它可以将 ES6 转换为 ES5。preset-env 对于插件的选择是基于某些开源项目的，比如 browserslist、compat-table 以及 electron-to-chromium。我们常用 <code>.browserslistrc</code> 来设置我们预想满足的目标运行环境，如：</p><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&gt; 0.25%</span></span>
<span class="line"><span>not dead</span></span></code></pre></div><p>要详细说的是 preset-env 的重要配置之一：<code>useBuiltIns</code>。</p><p>useBuiltIns 从其名字来说是“使用内置”，“内置”的什么呢？从官方看来是<code>polyfills</code>。它的取值可以是以下三种：</p><ol><li><code>false</code>：</li></ol><p>不使用内置的<code>polyfills</code>，这意味着你需要自行解决必要的<code>polyfills</code>问题。</p><ol start="2"><li>&quot;entry&quot;：</li></ol><p>只在“入口模块”处导入<code>polyfills</code>，你需要“根模块”写上<code>import &quot;core-js&quot;</code> 和 <code>import &quot;regenerator-runtime/runtime&quot;</code>，babel 会自动展开全部必要模块导入<code>import &quot;core-js/modules/X&quot;</code>，X 是根据你配置的目标环境选择出来的 <code>polyfill</code>，如<code>es.string.pad-start、es.array.unscopables.flat</code>。 注意，如果你没有写<code>import &quot;core-js&quot;</code>，则不会展开任何导入（import）语句。</p><ol start="3"><li>&quot;usage&quot;：</li></ol><p>你不用写什么了，babel 会根据你配置的目标环境，在你使用到一些“ES6特性X”的时候，自动补充<code>import &quot;core-js/modules/X&quot;</code>。</p><p>另一个选项 <code>corejs</code>，指定的是使用的 <code>corejs</code> 的版本，<code>corejs</code> 需要自己安装：</p><p><code>npm i -S core-js@2</code>或者 <code>npm i -S core-js@3</code>， <code>corejs</code> 只在 <code>useBuiltIns</code>取值为 <code>entry</code> 或 <code>usage</code> 的时候有用，因为 <code>Babel</code> 所谓内置的 polyfills 工具就是 <code>corejs</code>。<code>corejs</code>可以配置为 2 或 3。</p><h4 id="polyfill和runtime的区别" tabindex="-1">polyfill和runtime的区别 <a class="header-anchor" href="#polyfill和runtime的区别" aria-label="Permalink to &quot;polyfill和runtime的区别&quot;">​</a></h4><h5 id="polyfill" tabindex="-1">polyfill <a class="header-anchor" href="#polyfill" aria-label="Permalink to &quot;polyfill&quot;">​</a></h5><p>polyfill的英文意思是填充工具，意义就是兜底的东西；为什么会有polyfill这个概念，因为ECMASCRIPT一直在发布新的api，当使用这些新的api的时候，在旧版本的浏览器上是无法使用的，因为旧的版本上是没有提供这些新的api的，所以为了让代码也能在旧的浏览器上跑起来，于是手动添加对应的api，这就是polyfill，如下图所示；</p><p><img src="`+r+`" alt=""></p><p><code>polyfill</code>是会污染原来的全局环境的（因为新的原生对象、API这些都直接由polyfill引入到全局环境）。这样就很容易会发生冲突。对于库library来说，是供外部使用的，但外部的环境并不在library的可控范围。所以runtime就是解决这个问题的，避免全局污染。</p><p><a href="https://www.babeljs.cn/docs/babel-plugin-transform-runtime" target="_blank" rel="noreferrer"><code>babel-plugin-transform-runtime</code></a> 插件依赖<a href="https://www.babeljs.cn/docs/babel-runtime" target="_blank" rel="noreferrer">babel-runtime</a>，<code>babel-runtime</code>是真正提供<code>runtime</code>环境的包；也就是说<code>transform-runtime</code>插件是把js代码中使用到的新原生对象和静态方法转换成对runtime实现包的引用，举个例子如下：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输入的ES6代码</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sym </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Symbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 通过transform-runtime转换后的ES5+runtime代码 </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _symbol </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;babel-runtime/core-js/symbol&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sym </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, _symbol.default)();</span></span></code></pre></div><p>原本代码中使用的ES6新原生对象<code>Symbol</code>被<code>transform-runtime</code>插件转换成了<code>babel-runtime</code>的实现，既保持了<code>Symbol</code>的功能，同时又没有像<code>polyfill</code>那样污染全局环境（因为最终生成的代码中，并没有对Symbol的引用）。</p><h4 id="transform-runtime插件的功能" tabindex="-1">transform-runtime插件的功能 <a class="header-anchor" href="#transform-runtime插件的功能" aria-label="Permalink to &quot;transform-runtime插件的功能&quot;">​</a></h4><ol><li>把代码中的使用到的ES6引入的新原生对象和静态方法用<code>babel-runtime/core-js</code>导出的对象和方法替代</li><li>当使用<code>generators</code>或<code>async</code>函数时，用<code>babel-runtime/regenerator</code>导出的函数取代（类似polyfill分成regenerator和core-js两个部分）</li><li>把Babel生成的辅助函数改为用<code>babel-runtime/helpers</code>导出的函数来替代（babel默认会在每个文件顶部放置所需要的辅助函数，如果文件多的话，这些辅助函数就在每个文件中都重复了，通过引用<code>babel-runtime/helpers</code>就可以统一起来，减少代码体积）</li></ol><p>上述三点就是<code>transform-runtime</code>插件所做的事情，由此也可见，<code>babel-runtime</code>就是一个提供了<code>regenerator</code>、<code>core-js</code>和<code>helpers</code>的运行时库。</p><h2 id="core-js" tabindex="-1">core-js <a class="header-anchor" href="#core-js" aria-label="Permalink to &quot;core-js&quot;">​</a></h2><h3 id="core-js介绍" tabindex="-1">core-js介绍 <a class="header-anchor" href="#core-js介绍" aria-label="Permalink to &quot;core-js介绍&quot;">​</a></h3><p>其实core-js是我们能够使用新的API的最重要的包，然而一般情况它隐藏在webpack编译后的代码中，我们一般不会去查看，所以容易被遗忘，我们在webpack生成环境下，查看编译后的代码，可以看到例如<code>includes</code>就是从<code>core-js</code>导出到我们的代码去的。</p><p><img src="`+h+`" alt=""></p><h4 id="core-js是什么" tabindex="-1">core-js是什么 <a class="header-anchor" href="#core-js是什么" aria-label="Permalink to &quot;core-js是什么&quot;">​</a></h4><ul><li><strong>它是JavaScript标准库的polyfill</strong></li><li>它尽可能的进行模块化，让你能选择你需要的功能</li><li><strong>它可以不污染全局空间</strong></li><li>它和babel高度集成，可以对core-js的引入进行最大程度的优化</li></ul><h3 id="core-js-3-特性概览" tabindex="-1"><a href="https://github.com/zloirock/core-js/blob/master/docs/2019-03-19-core-js-3-babel-and-a-look-into-the-future.md#babelpreset-env" target="_blank" rel="noreferrer">core-js@3 特性概览</a> <a class="header-anchor" href="#core-js-3-特性概览" aria-label="Permalink to &quot;[core-js@3 特性概览](https://github.com/zloirock/core-js/blob/master/docs/2019-03-19-core-js-3-babel-and-a-look-into-the-future.md#babelpreset-env)&quot;">​</a></h3><ul><li>支持ECMAScript稳定功能，引入core-js@3冻结期间的新功能，比如flat</li><li>加入到ES2016-ES2019中的提案，现在已经被标记为稳定功能</li><li><strong>更新了提案的实现，增加了proposals配置项，由于提案阶段不稳定，需要谨慎使用</strong></li><li><strong>增加了对一些web标准的支持，比如URL 和 URLSearchParams</strong></li><li><strong>现在支持原型方法，同时不污染原型</strong></li><li>删除了过时的特性</li></ul><h3 id="core-js-3与babel" tabindex="-1">core-js@3与babel <a class="header-anchor" href="#core-js-3与babel" aria-label="Permalink to &quot;core-js@3与babel&quot;">​</a></h3><p>以前我们实现API的时候，会引入整个polyfill，其实polyfill只是包括了以下两个包</p><ul><li><code>core-js</code></li><li><code>regenerator-runtime</code>: Standalone runtime for Regenerator-compiled generator and async functions.即<code>generator</code>和<code>async</code>的polyfill包</li></ul><p><code>core-js@3</code>升级之后弃用了<code>@babel/polyfill</code>，以下是等价实现。polyfill是一个针对ES2015+环境的shim，实现上来说<code>babel-polyfill</code>包只是简单的把<code>core-js</code>和<code>regenerator runtime</code>包装了下。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// babel.config.ts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">presets</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;@babel/preset-env&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    useBuiltIns: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;entry&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// or &quot;usage&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    corejs: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;core-js/stable&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;regenerator-runtime/runtime&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//  Standalone runtime for Regenerator-compiled generator and async functions. 解决generate和async的兼用问题</span></span></code></pre></div><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><ul><li><a href="https://juejin.cn/post/6976501655302832159" target="_blank" rel="noreferrer">你所需要知道的最新的babel兼容性实现方案</a></li></ul><p>目前，<code>babel</code>处理兼容性问题有两种方案：</p><ol><li><code>@babel/preset-env</code> + <code>corejs@3</code>实现<strong>简单语法转换</strong> + <strong>复杂语法注入<code>api</code>替换</strong> + <strong>在全局或者构造函数静态属性、实例属性上添加<code>api</code></strong> ，支持全量加载和按需加载，我们简称<code>polyfill</code>方案；</li><li><code>@babel/preset-env</code> + <code>@babel/runtime-corejs3</code> + <code>@babel/plugin-transform-runtime</code>实现<strong>简单语法转换</strong> + <strong>引入替换复杂语法和<code>api</code></strong> ，只支持按需加载，简称<code>runtime</code>方案。</li></ol><p>两种方案一个依赖核心包<code>core-js</code>，一个依赖核心包<code>core-js-pure</code>，两种方案各有优缺点：</p><ol><li><code>polyfill</code>方案很明显的缺点就是会造成全局污染，而且会注入冗余的工具代码；优点是可以根据浏览器对新特性的支持度来选择性的进行兼容性处理；</li><li><code>runtime</code>方案虽然解决了<code>polyfill</code>方案的那些缺点，但是不能根据浏览器对新特性的支持度来选择性的进行兼容性处理，也就是说只要在代码中识别到的<code>api</code>，并且该<code>api</code>也存在<code>core-js-pure</code>包中，就会自动替换，这样一来就会造成一些不必要的转换，从而增加代码体积。</li></ol><p>所以，<code>polyfill</code>方案比较适合单独运行的业务项目，如果你是想开发一些供别人使用的第三方工具库，则建议你使用<code>runtime</code>方案来处理兼容性方案，以免影响使用者的运行环境。</p><h3 id="vue-cli3下-browserslistrc文件含义" tabindex="-1">vue/cli3下.browserslistrc文件含义 <a class="header-anchor" href="#vue-cli3下-browserslistrc文件含义" aria-label="Permalink to &quot;vue/cli3下.browserslistrc文件含义&quot;">​</a></h3><p>browserslist是用来配置项目的目标浏览器和nodejs版本范围，也就是通常说的兼容哪些浏览器的版本。</p><ul><li>&quot; &gt;1%&quot; :代表着全球超过1%人使用的浏览器</li><li>“last 2 versions” : 表示所有浏览器兼容到最后两个版本</li><li>“not ie &lt;=8” :表示IE浏览器版本大于8（实则用npx browserslist 跑出来不包含IE9 ）</li><li>“safari &gt;=7”:表示safari浏览器版本大于等于7</li></ul><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&gt; 1%</span></span>
<span class="line"><span>last 2 versions</span></span>
<span class="line"><span>not dead</span></span></code></pre></div><h3 id="实现一个简单的按需打包功能babel插件" tabindex="-1">实现一个简单的按需打包功能babel插件 <a class="header-anchor" href="#实现一个简单的按需打包功能babel插件" aria-label="Permalink to &quot;实现一个简单的按需打包功能babel插件&quot;">​</a></h3><p>例如 <code>ElementUI</code> 中把 <code>import { Button } from &#39;element-ui&#39;</code> 转成 <code>import Button from &#39;element-ui/lib/button&#39;</code></p><p>可以先对比下 <code>AST</code> ：</p><details class="details custom-block"><summary>点击查看代码</summary><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// import { Button } from &#39;element-ui&#39;</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    &quot;type&quot;: &quot;Program&quot;,</span></span>
<span class="line"><span>    &quot;body&quot;: [</span></span>
<span class="line"><span>        {</span></span>
<span class="line"><span>            &quot;type&quot;: &quot;ImportDeclaration&quot;,</span></span>
<span class="line"><span>            &quot;specifiers&quot;: [</span></span>
<span class="line"><span>                {</span></span>
<span class="line"><span>                    &quot;type&quot;: &quot;ImportSpecifier&quot;,</span></span>
<span class="line"><span>                    &quot;local&quot;: {</span></span>
<span class="line"><span>                        &quot;type&quot;: &quot;Identifier&quot;,</span></span>
<span class="line"><span>                        &quot;name&quot;: &quot;Button&quot;</span></span>
<span class="line"><span>                    },</span></span>
<span class="line"><span>                    &quot;imported&quot;: {</span></span>
<span class="line"><span>                        &quot;type&quot;: &quot;Identifier&quot;,</span></span>
<span class="line"><span>                        &quot;name&quot;: &quot;Button&quot;</span></span>
<span class="line"><span>                    }</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            ],</span></span>
<span class="line"><span>            &quot;source&quot;: {</span></span>
<span class="line"><span>                &quot;type&quot;: &quot;Literal&quot;,</span></span>
<span class="line"><span>                &quot;value&quot;: &quot;element-ui&quot;,</span></span>
<span class="line"><span>                &quot;raw&quot;: &quot;&#39;element-ui&#39;&quot;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    ],</span></span>
<span class="line"><span>    &quot;sourceType&quot;: &quot;module&quot;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// import Button from &#39;element-ui/lib/button&#39;</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    &quot;type&quot;: &quot;Program&quot;,</span></span>
<span class="line"><span>    &quot;body&quot;: [</span></span>
<span class="line"><span>        {</span></span>
<span class="line"><span>            &quot;type&quot;: &quot;ImportDeclaration&quot;,</span></span>
<span class="line"><span>            &quot;specifiers&quot;: [</span></span>
<span class="line"><span>                {</span></span>
<span class="line"><span>                    &quot;type&quot;: &quot;ImportDefaultSpecifier&quot;,</span></span>
<span class="line"><span>                    &quot;local&quot;: {</span></span>
<span class="line"><span>                        &quot;type&quot;: &quot;Identifier&quot;,</span></span>
<span class="line"><span>                        &quot;name&quot;: &quot;Button&quot;</span></span>
<span class="line"><span>                    }</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            ],</span></span>
<span class="line"><span>            &quot;source&quot;: {</span></span>
<span class="line"><span>                &quot;type&quot;: &quot;Literal&quot;,</span></span>
<span class="line"><span>                &quot;value&quot;: &quot;element-ui/lib/button&quot;,</span></span>
<span class="line"><span>                &quot;raw&quot;: &quot;&#39;element-ui/lib/button&#39;&quot;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    ],</span></span>
<span class="line"><span>    &quot;sourceType&quot;: &quot;module&quot;</span></span>
<span class="line"><span>}</span></span></code></pre></div></details><p>可以发现， <code>specifiers</code> 的 <code>type</code> 和 <code>source</code> 的 <code>value</code>、<code>raw</code> 不同。</p><p>然后 <code>ElementUI</code> 官方文档中，<code>babel-plugin-component</code> 的配置如下：</p><details class="details custom-block"><summary>点击查看代码</summary><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// 如果 plugins 名称的前缀为 &#39;babel-plugin-&#39;，你可以省略 &#39;babel-plugin-&#39; 部分</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  &quot;presets&quot;: [[&quot;es2015&quot;, { &quot;modules&quot;: false }]],</span></span>
<span class="line"><span>  &quot;plugins&quot;: [</span></span>
<span class="line"><span>    [</span></span>
<span class="line"><span>      &quot;component&quot;,</span></span>
<span class="line"><span>      {</span></span>
<span class="line"><span>        &quot;libraryName&quot;: &quot;element-ui&quot;,</span></span>
<span class="line"><span>        &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>    ]</span></span>
<span class="line"><span>  ]</span></span>
<span class="line"><span>}</span></span></code></pre></div><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> babel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@babel/core&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> str</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`import { Button } from &#39;element-ui&#39;\`</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> babel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(str, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    plugins: [</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">types</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                visitor: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    ImportDeclaration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">opts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                        const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">specifiers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">source</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> path</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                        // 比较 source 的 value 值 与配置文件中的库名称</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (source.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> opts.libraryName) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                            const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> arr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> specifiers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">specifier</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                t.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">importDeclaration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                              </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                    [t.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ImportDefaultSpecifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(specifier.local)],</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                                    // 拼接详细路径</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                    t.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stringLiteral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">source</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">value</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}/lib/\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">specifier</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">local</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                            ))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                            path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replaceWithMultiple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arr)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// import Button from &quot;element-ui/lib/Button&quot;;</span></span></code></pre></div></details><h2 id="按需-polyfill-是怎么实现的" tabindex="-1">按需 polyfill 是怎么实现的 <a class="header-anchor" href="#按需-polyfill-是怎么实现的" aria-label="Permalink to &quot;按需 polyfill 是怎么实现的&quot;">​</a></h2><p>polyfill即垫片，使用比较新的api开发，但浏览器可能不支持，在运行业务代码前，在全局注入一些 api 的实现，处理兼容问题。但用户浏览器和版本多种多样，如何按需加载polyfill呢</p><p>答案就是 <code>preset-env</code>，它实现了按需引入 <code>polyfill</code>。</p><p>这里的 <code>preset-env</code> 指的是 babel 的 <code>@babel/preset-env</code> 和 postcss 的 <code>postcss-preset-env</code>，它们一个是按需做语法转换、按需引入 JS 的 polyfill，一个是按需做添加 prefix 等 css 兼容处理。</p><p>他们分别是针对 JS 和 CSS 的，但他们两个的原理差不多。</p><h3 id="babel-preset-env" tabindex="-1">@babel/preset-env <a class="header-anchor" href="#babel-preset-env" aria-label="Permalink to &quot;@babel/preset-env&quot;">​</a></h3><p><code>@babel/preset-env</code> 支持通过 <code>targets</code> 来指定目标环境： eg:</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   &quot;presets&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;@babel/preset-env&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            &quot;targets&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&gt; 0.25%, not dead&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这里的 <code>targets</code> 是 <code>browserslist</code> 的查询字符串，它可以解析查询字符串返回对应的浏览器版本：</p><p>有了这些目标浏览器的版本，还需要知道各种特性是在什么版本支持的：</p><p>babel 维护了一个数据库，在 <a href="https://github.com/babel/babel/tree/main/packages/babel-compat-data/data" target="_blank" rel="noreferrer"><code>@babel/compat-data</code></a> 这个包里,eg:</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;es6.array.copy-within&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;chrome&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;45&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;opera&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;32&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;edge&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;12&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;firefox&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;32&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;safari&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;9&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;4&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;deno&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;ios&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;9&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;samsung&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;5&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;rhino&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1.7.13&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;opera_mobile&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;32&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;electron&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;0.31&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这样就能根据目标浏览器的版本，过滤出哪些特性是支持的，哪些是不支持的。然后只对不支持的特性做语法转换和 polyfill 即可</p><p><img src="`+k+'" alt=""></p><p><code>postcss-preset-env</code>原理类似</p><p>babel 是通过 <code>@babel/preset-env</code> 来做按需 <code>polyfill</code> 和转换的，原理是通过 <code>browserslist</code> 来查询出目标浏览器版本，然后根据 <code>@babel/compat-data</code> 的数据库来过滤出这些浏览器版本里哪些特性不支持，之后引入对应的插件处理。</p><p>postcss 是通过 <code>postcss-preset-env</code> 来做按需 <code>prefix</code> 等的，原理也是通过 <code>browserslist</code> 来查询出目标浏览器版本，然后根据 <code>cssdb</code> 的数据库（来自 caniuse）来过滤出不支持的 CSS 特性，然后对这些 CSS 做处理即可。</p>',90)]))}const F=a(c,[["render",d]]);export{m as __pageData,F as default};
