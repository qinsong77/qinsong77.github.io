import{_ as s,c as a,o as e,ag as l}from"./chunks/framework.BgId8OS5.js";const o=JSON.parse('{"title":"Webpack5","description":"","frontmatter":{"title":"Webpack5"},"headers":[],"relativePath":"fe/webpack/webpack5.md","filePath":"fe/webpack/webpack5.md","lastUpdated":1647794141000}'),n={name:"fe/webpack/webpack5.md"};function p(t,i,h,k,r,d){return e(),a("div",null,i[0]||(i[0]=[l(`<h2 id="general-direction" tabindex="-1">General direction <a class="header-anchor" href="#general-direction" aria-label="Permalink to &quot;General direction&quot;">​</a></h2><p>This release focus on the following:</p><ul><li><p>Improve build performance with Persistent Caching.</p></li><li><p>Improve Long Term Caching with better algorithms and defaults.</p></li><li><p>Improve bundle size with better Tree Shaking and Code Generation.</p></li><li><p>Improve compatibility with the web platform.</p></li><li><p>Clean up internal structures that were left in a weird state while implementing features in v4 without introducing any breaking changes.</p></li><li><p>Prepare for future features by introducing breaking changes now, allowing us to stay on v5 for as long as possible.</p></li><li><p>通过持久化硬盘缓存能力来提升构建性能</p></li><li><p>通过更好的算法来改进长期缓存（降低产物资源的缓存失效率）</p></li><li><p>通过更好的 Tree Shaking 能力和代码的生成逻辑来优化产物的大小</p></li><li><p>改善 web 平台的兼容性能力</p></li><li><p>清除了内部结构中，在 Webpack4 没有重大更新而引入一些新特性时所遗留下来的一些奇怪的 state</p></li><li><p>通过引入一些重大的变更为未来的一些特性做准备，使得能够长期的稳定在 Webpack5 版本上</p></li></ul><h2 id="新特性介绍" tabindex="-1">新特性介绍 <a class="header-anchor" href="#新特性介绍" aria-label="Permalink to &quot;新特性介绍&quot;">​</a></h2><ul><li>持久化缓存</li><li>moduleIds &amp; chunkIds的优化</li><li>更智能的tree shaking</li><li>nodeJs的polyfill脚本被移除</li><li>支持生成e6/es2015的代码</li><li>SplitChunk和模块大小</li><li>Module Federation</li></ul><p><a href="https://juejin.cn/post/7023242274876162084" target="_blank" rel="noreferrer">webpack5总结</a></p><h3 id="持久化缓存" tabindex="-1">持久化缓存 <a class="header-anchor" href="#持久化缓存" aria-label="Permalink to &quot;持久化缓存&quot;">​</a></h3><p>在webpack5之前，可以使用cache-loader将编译结构写入硬盘缓存，还可以使用babel-loader，设置option.cacheDirectory将babel-loader编译的结果写进磁盘。</p><p>在webpack5中，默认开启缓存，缓存默认是在内存里。可以对cache进行设置</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.export </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cache: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        type:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;filesystem&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//  &#39;memory&#39; | &#39;filesystem&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        cacheDirectory: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;node_modules/.cache/webpack&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 默认将缓存存储在 node_modules/.cache/webpack</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 缓存依赖，当缓存依赖修改时，缓存失效</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        buildDependencies:{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        	// 将你的配置添加依赖，更改配置时，使得缓存失效</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        	config: [__filename]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    	} </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>默认情况下webpack 会假定其所处的 <code>node_modules</code> 目录仅由包管理器修改，将会跳过hash和时间戳处理，出于性能考虑，仅使用package的名称和版本。</li><li>当设置 cache.type: &quot;filesystem&quot; 时，webpack 会在内部以分层方式启用文件系统缓存和内存缓存。从缓存读取时，会先查看内存缓存，如果内存缓存未找到，则降级到文件系统缓存。写入缓存将同时写入内存缓存和文件系统缓存。</li><li>文件系统缓存不会直接将对磁盘写入的请求进行序列化。它将等到编译过程完成且编译器处于空闲状态才会执行。如此处理的原因是序列化和磁盘写入会占用资源，并且我们不想额外延迟编译过程。</li><li>缓存淘汰策略设计：文件缓存存储在 node_modules/.cache/webpack，对于一个缓存集合，最大限度应该不超过 5 个缓存内容，最大累积资源占用不超过 500 MB，当逼近或超过 500MB 的阈值时，优先删除最老的缓存内容。同时，也设计了缓存的有效时长为 2 个星期。</li></ul><h3 id="moduleids-chunkids的优化" tabindex="-1">moduleIds &amp; chunkIds的优化 <a class="header-anchor" href="#moduleids-chunkids的优化" aria-label="Permalink to &quot;moduleIds &amp; chunkIds的优化&quot;">​</a></h3><ul><li>chunk：webpack打包最终生成的单独文件块，最终生成的单独文件，一个文件对应一个chunk。</li><li>module：每一个源码 js 文件其实都可以看成一个 module。</li></ul><p>chunkId的缺点</p><ul><li>webpack5改进了moduleIds 和 chunkIds的确定。在webpack5之前，没有从entry打包的chunk文件，都会以1，2，3...的文件命名方式输出。(文件名称后的hash值是用chunkhash生成的)</li><li>这样会造成一个后果是，当删除或者暂时不使用1.js这个文件后，那么2.js-&gt;1.js，3.js-&gt;2.js，这样就会造成原本线上的2.js请求时会造成缓存失效。</li><li>在webpack5之前也是可以通过<code>webpackChunkName</code>来解决命名问题</li></ul><h3 id="splitchunk和模块大小" tabindex="-1">SplitChunk和模块大小 <a class="header-anchor" href="#splitchunk和模块大小" aria-label="Permalink to &quot;SplitChunk和模块大小&quot;">​</a></h3><ul><li>模块现在能够以更好的方式表示大小，而不是显示单个数字和不同类型的大小。</li><li>默认情况下，只能处理 javascript 的大小，但是你现在可以传递多个值来管理它们:</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.export </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    optimization: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      splitChunks: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      minSize: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            javascript: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            style: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="module-federation" tabindex="-1">Module Federation <a class="header-anchor" href="#module-federation" aria-label="Permalink to &quot;Module Federation&quot;">​</a></h3><p>动态加载 可以允许代码在运行时按需加载另一个应用的代码。</p><ul><li>Module Federation 使 JavaScript 应用得以从另一个 JavaScript 应用中动态地加载代码 —— 同时共享依赖。让代码直接在项目间利用 CDN 直接共享，不再需要本地安装 Npm 包、构建再发布了！</li></ul>`,21)]))}const E=s(n,[["render",p]]);export{o as __pageData,E as default};
